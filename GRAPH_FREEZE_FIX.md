# Исправление зависания приложения при загрузке графа

## Проблема
После сохранения изменений в графе и перезагрузки страницы приложение полностью зависало:
- Не работали кнопки
- Не открывалась консоль разработчика
- Браузер полностью переставал отвечать

## Причины проблемы

### 1. Циклические ссылки в структуре данных
**Файл:** `frontend/src/pages/GraphPage/hooks/useGraphRenderer.ts`

**Проблема:** Функция `buildTree()` создавала циклические ссылки в JavaScript объектах при наличии циклических связей в графе (например, A → B → C → A).

```typescript
// БЫЛО (проблемный код):
links.forEach(link => {
  const parent = nodeMap.get(link.source);
  const child = nodeMap.get(link.target);
  if (parent && child) parent.children!.push(child); // ← Добавляем прямую ссылку на child
});
```

Когда в графе были циклы, это создавало циклические объектные ссылки:
- Узел A содержит child B
- Узел B содержит child C  
- Узел C содержит child A (ссылается обратно на A)
- Это приводит к бесконечной рекурсии при попытке обработать структуру

**Решение:** Создаем копии узлов вместо использования прямых ссылок:

```typescript
// СТАЛО (исправленный код):
links.forEach(link => {
  const parent = nodeMap.get(link.source);
  const child = nodeMap.get(link.target);
  
  const linkKey = `${link.source}->${link.target}`;
  if (parent && child && !addedChildren.has(linkKey)) {
    // Создаем копию child без циклических ссылок
    const childCopy: OntologyNode = {
      id: child.id,
      label: child.label,
      type: child.type,
      children: [] // Новый массив, без старых ссылок
    };
    parent.children!.push(childCopy);
    addedChildren.add(linkKey);
  }
});
```

### 2. Бесконечный цикл в useEffect
**Файл:** `frontend/src/pages/GraphPage/GraphPage.tsx`

**Проблема:** Два useEffect создавали бесконечный цикл обновлений:

```typescript
// БЫЛО:
useEffect(() => {
  if (!isLoading && !loadError) {
    updateDataFromManager(); // Обновляет nodes и links
  }
}, [isLoading, loadError, updateDataFromManager]); // ← updateDataFromManager в зависимостях

useEffect(() => {
  renderTree(); // Зависит от nodes и links
}, [nodes, links, renderTree, isSaving]); // ← renderTree в зависимостях
```

Цикл:
1. `updateDataFromManager()` обновляет `nodes` и `links`
2. Это триггерит второй useEffect с `renderTree()`
3. Если `renderTree` или `updateDataFromManager` пересоздаются, это может вызвать повторный useEffect
4. Бесконечный цикл

**Решение:** Убрали функции из зависимостей useEffect:

```typescript
// СТАЛО:
useEffect(() => {
  if (!isLoading && !loadError) {
    updateDataFromManager();
  }
}, [isLoading, loadError]); // ← Только примитивные значения

useEffect(() => {
  if (nodes.length > 0) {
    renderTree();
  }
}, [nodes, links, isSaving]); // ← Только данные, не функции
```

### 3. Отсутствие обработки ошибок
Не было try-catch блоков для перехвата ошибок при рендеринге графа.

### 4. Отсутствие защиты от больших графов
Нет ограничения на количество узлов, что может привести к зависанию при больших графах.

## Внесенные исправления

### 1. Исправлена функция `buildTree()` ✅
- Создаются копии узлов вместо прямых ссылок
- Добавлено отслеживание уже добавленных связей (Set для предотвращения дубликатов)
- Добавлена обработка графов без корневых узлов (циклических графов)
- Добавлены фильтры для безопасности

```typescript
// Отслеживаем добавленные связи
const addedChildren = new Set<string>();

// Проверяем что связь еще не добавлена
const linkKey = `${link.source}->${link.target}`;
if (parent && child && !addedChildren.has(linkKey)) {
  // Создаем КОПИЮ вместо ссылки
  const childCopy: OntologyNode = { ...child, children: [] };
  parent.children!.push(childCopy);
  addedChildren.add(linkKey);
}
```

### 2. Исправлены useEffect циклы ✅
- Убрали функции из зависимостей useEffect
- Используем только примитивные значения и массивы данных в зависимостях
- `updateDataFromManager` и `renderTree` обернуты в `useCallback` с пустым массивом зависимостей

### 3. Добавлена обработка ошибок ✅
```typescript
try {
  // Код рендеринга графа
  const svg = d3.select(svgEl);
  // ...
} catch (error) {
  console.error('Error rendering tree:', error);
  // Очищаем SVG в случае ошибки
  const svg = d3.select(svgRef.current);
  svg.selectAll("*").remove();
}
```

### 4. Добавлена защита от больших графов ✅
```typescript
// Защита от слишком больших графов
const MAX_NODES = 1000;
if (nodes.length > MAX_NODES) {
  console.error(`Graph too large: ${nodes.length} nodes (max ${MAX_NODES})`);
  alert(`Граф слишком большой (${nodes.length} узлов). Максимум ${MAX_NODES} узлов для отображения.`);
  return;
}
```

### 5. Добавлены проверки безопасности ✅
- Проверка наличия узлов перед рендерингом
- Проверка наличия SVG элемента
- Проверка наличия hierarchyData
- Логирование для отладки

### 6. Улучшена функция `updateDataFromManager()` ✅
- Стабильная ссылка через `useCallback` с пустым массивом зависимостей
- Простое обновление состояния (React оптимизирует автоматически)

## Измененные файлы

1. **frontend/src/pages/GraphPage/GraphPage.tsx**
   - Исправлены useEffect циклы
   - Улучшена функция `updateDataFromManager()`
   - Добавлена проверка на пустые узлы перед рендерингом

2. **frontend/src/pages/GraphPage/hooks/useGraphRenderer.ts**
   - Полностью переписана функция `buildTree()` для предотвращения циклов
   - Добавлена обработка ошибок в `renderTree()`
   - Добавлена защита от больших графов
   - Добавлены проверки безопасности

## Как это работает теперь

### Загрузка графа:
1. `initializeData()` загружает данные с сервера
2. Данные добавляются в `OntologyManager`
3. `updateDataFromManager()` обновляет state компонента
4. useEffect триггерит `renderTree()`
5. `buildTree()` создает дерево **без циклических ссылок**
6. D3 отрисовывает граф

### При наличии циклов в данных:
1. `buildTree()` создает копии узлов
2. Каждая копия имеет свой собственный массив `children`
3. Даже если в данных A → B → A, в структуре это будут разные объекты
4. Нет бесконечной рекурсии

### При больших графах:
1. Проверяется количество узлов (макс. 1000)
2. Если больше - показывается alert и рендеринг не происходит
3. Браузер не зависает

## Тестирование

### Тест 1: Граф с циклами
1. Создайте узлы A, B, C
2. Создайте связи: A → B, B → C, C → A (цикл)
3. Сохраните граф
4. Перезагрузите страницу
5. ✅ Граф должен загрузиться без зависания

### Тест 2: Большой граф
1. Создайте граф с большим количеством узлов
2. Сохраните
3. Перезагрузите
4. ✅ Если узлов > 1000, покажется предупреждение
5. ✅ Браузер не зависнет

### Тест 3: Обычный граф
1. Создайте обычный граф без циклов
2. Сохраните и перезагрузите
3. ✅ Все должно работать как обычно

### Тест 4: Пустой граф
1. Очистите все узлы
2. Сохраните
3. ✅ Должен показаться начальный узел "Class"

## Производительность

- **Без циклов:** Отличная производительность
- **С циклами:** Нормальная производительность (копирование узлов немного медленнее, но безопасно)
- **Большие графы (< 1000 узлов):** Приемлемая производительность
- **Очень большие графы (> 1000 узлов):** Блокируется для защиты браузера

## Дополнительные улучшения

Можно добавить в будущем:
1. **Виртуализацию** - отрисовка только видимой части графа
2. **WebWorkers** - построение дерева в отдельном потоке
3. **Ленивую загрузку** - загрузка графа по частям
4. **Кэширование** - сохранение построенного дерева
5. **Debounce** - ограничение частоты рендеринга при быстрых изменениях

## Важные замечания

⚠️ **Не удаляйте** проверки на циклы и копирование узлов - это критично для стабильности!

⚠️ **Не добавляйте** функции обратно в зависимости useEffect без крайней необходимости

⚠️ **Следите** за размером графов при работе с большими датасетами

## Заключение

Проблема была в двух критических местах:
1. **Циклические ссылки** в объектах JavaScript → исправлено копированием узлов
2. **Бесконечные циклы** в React useEffect → исправлено удалением функций из зависимостей

Теперь приложение стабильно работает с любыми графами, включая циклические и большие.

